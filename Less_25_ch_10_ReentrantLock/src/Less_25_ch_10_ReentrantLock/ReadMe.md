### Java Lock API

Обычно в многопоточной среде для достижения потокобезопасности, используется
ключевое слово synchronized. Однако у данного способа существует конкурент в
виде Lock API.

В большинстве случаев, ключевое слово synchronized является хорошим выбором,
но все же он имеет некоторые недостатки. Именно поэтому еще в Java 1.5 был
введен Concurrency API и пакет java.util.concurrent.locks c интерфейсом Lock
и некоторыми дополнительными классами, которые усовершенствовали механизм
блокировки.

Важные моменты в Concurrency Lock API:

    1. Lock: Это базовый интерфейс в Lock API. Он обеспечивает все функции ключевого
             слова synchronized, добавляя новые методы для удобной работы.
               Например:
                - метод lock() - получить lock для работы;
                - метод unlock() - освободить lock;
                - метод tryLock() - ожидать lock на протяжении определенного времени;
                - метод newCondition() - создать Condition.
                - метод lockInterruptibly() throws InterruptedException - ожидает, пока не
                  будет получена блокировка, если поток не прерван
                - метод boolean tryLock() - пытается получить блокировку, если блокировка получена,
                  то возвращает true. Если блокировка не получена, то возвращает false. В отличие
                  от метода lock() не ожидает получения блокировки, если она недоступна.

    2. Condition: Это похоже на wait-notify модель с рядом дополнительных функций. Объект
                  Condition всегда создается с помощью объекта Lock. Такой важный метод, как
                  await() очень похож на wait(), а методы signal(), signalAll() похожи на
                  notify() и notifyAll().

    3. ReadWriteLock содержит пару связанных локов: первый только для чтения, второй для записи.
                     Лок для чтения может предоставлять доступ одновременно для нескольких потоков.

    4. Класс ReentrantLock — это наиболее используемая реализация интерфейса Lock. Эта реализация
                             интерфейса Lock аналогична использованию ключевого слова synchronized.
                             Кроме реализации интерфейса Lock, ReentrantLock содержит ряд вспомогательных
                             методов для работы с потоками.

Организация блокировки в общем случае довольно проста: для получения блокировки вызывается метод lock(),
а после окончания работы с общими ресурсами вызывается метод unlock(), который снимает блокировку.

Объект Condition позволяет управлять блокировкой.

Как правило, для работы с блокировками используется класс ReentrantLock из пакета java.util.concurrent.locks.
Данный класс реализует интерфейс Lock, как указано выше. И как synchronized, обеспечивает многопоточность,
но имеет дополнительные возможности, связанные с опросом о блокировании (lock polling), ожиданием блокирования
в течение определенного времени и прерыванием ожидания блокировки. Кроме того, ReentrantLock предлагает гораздо
более высокую эффективность функционирования в условиях жесткой состязательности.

Другими словами, когда несколько потоков пытаются получить доступ к совместно используемому ресурсу, виртуальной
машине JVM потребуется меньше времени на установление очередности потоков и больше времени на ее выполнение.

В переводе reentrant может означать повторно используемый (повторный вход). Что это означает - блокировка с
повторным входом? Это учет количества получения определенных блокировок. Т.е. один и тот же поток повторно
получает одну и ту же блокировку. Но для того, чтобы реально разблокировать необходимо уже будет два раза
снять блокировку. Это аналогично использованию synchronized; если поток повторно входит в синхронный блок,
защищенный монитором, то блокировка не будет снята при выходе потока из второго (или последующего) блока
synchronized, блокировка будет снята только когда поток выйдет из первого блока synchronized, в который он
вошел под защитой монитора.

Одним из интересных методов интерфейса Lock и его реализации ReentrantLock является запрос блокировки
с возможностью прерывания процесса ожидания. Т.е. если поток запрашивает блокировку методом
lockInterruptibly() и не получает ее сразу же, то переходит в процесс ожидания.

Методом interrupt работу потока можно прервать. Тогда ожидающий блокировки поток просыпается, и генерируется
исключительная ситуация InterruptedException. После этого попыток доступа к защищенному ресурсу не делается
и освобождать блокировку не требуется.
