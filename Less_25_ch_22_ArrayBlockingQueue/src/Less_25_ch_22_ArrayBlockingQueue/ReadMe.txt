************ Блокирующие очереди пакета concurrent ************

Пакет java.util.concurrent включает классы для формирования блокирующих очередей с поддержкой
многопоточности. Блокирующие очереди используются в тех случаях, когда нужно выполнить
(проверить выполненение) какие-либо условия для продолжения потоками своей работы.

Блокирующие очереди могут реализовывать интерфейсы BlockingQueue, BlockingDeque, TransferQueue.
В пакете java.util.concurrent имеются следующие реализации блокирующих очередей :

- ArrayBlockingQueue — очередь, реализующая классический кольцевой буфер;
- LinkedBlockingQueue — односторонняя очередь на связанных узлах;
- LinkedBlockingDeque — двунаправленная очередь на связанных узлах;

- SynchronousQueue — блокирующую очередь без емкости (операция добавления одного потока находится
  в ожидании соответствующей операции удаления в другом потоке);

- LinkedTransferQueue — реализация очереди на основе интерфейса TransferQueue;
- DelayQueue — неограниченная блокирующая очередь, реализующая интерфейс Delayed;
- PriorityBlockingQueue — реализация очереди на основе интерфейса PriorityQueue.

Использование очередей пакета java.util.concurrent может стать решением проблем взаимных
блокировок и «голодания».

*** Интерфейс BlockingQueue ***

Интерфейс BlockingQueue определяет блокирующую очередь, наследующую свойства интерфейса Queue,
в которой элементы хранятся в порядке «первый пришел, первый вышел» (FIFO – first in, first out).
Реализация данного интерфейса обеспечивает блокировку потока в двух случаях :
- при попытке получения элемента из пустой очереди;
- при попытке размещения элемента в полной очереди.

Когда поток пытается получить элемент из пустой очереди, то он переводится в состояние ожидания до
тех пор, пока какой-либо другой поток не разместит элемент в очереди. Аналогично при попытке положить
элемент в полную очередь; поток ставится в ожидание до тех пор, пока другой поток не заберет элемент
из очереди и, таким образом, не освободит место в ней. Естественно, понятие "полная очередь"
подразумевает ограничение размера очереди.

BlockingQueue решает проблему передачи собранных одним потоком элементов для обработки в другой поток
без явных хлопот о проблемах синхронизации.

Основные методы интерфейса BlockingQueue:
- boolean add(E e) - Немедленное добавление элемента в очередь, если это возможно;
                     метод возвращает true при благополучном завершении операции,
                     либо вызывает IllegalStateException, если очередь полная.

- boolean contains(Object o) - Проверка наличия объекта в очереди; если объект найден в
                               очереди метод вернет true.

- boolean offer(E e) - Немедленное размещение элемента в очереди при наличие свободного места;
                       метод вернет true при успешном завершении операции, в противном случае
                       вернет false.

- boolean offer(E e, long timeout, TimeUnit unit) - Размещение элемента в очереди при наличии
                                                    свободного места; при необходимости определенное
                                                    ожидание времени, пока не освободиться место.

- E poll(long timeout, TimeUnit unit) - Чтение и удаление элемента из очереди в течение определенного
                                        времени (таймаута).

- void put(E e) - Размещение элемента в очереди, ожидание при необходимости освобождения свободного места.
- int remainingCapacity() - Получения количества элементов, которое можно разместить в очереди без
                            блокировки, либо Integer.MAX_VALUE при отсутствии внутреннего предела.

- boolean remove(Object o) - Удаление объекта из очереди, если он в ней присутствует.
- E take() - Получение с удалением элемента из очереди, при необходимости ожидание пока элемент
             не станет доступным.

BlockingQueue не признает нулевых элементов (null) и вызывает NullPointerException при попытке
добавить или получить такой элемент. Нулевой элемент возвращает метод poll, если в течение таймаута
не был размещен в очереди очередной элемент.

Методы BlockingQueue можно разделить на 4 группы, по-разному реагирующие на невозможность выполнения
операции в текущий момент и откладывающие их выполнение на время:
- первые вызывают Exception;
- вторые возвращают определенное значение (null или false);
- третьи блокируют поток на неопределенное время до момента выполнения операции;
- четвертые блокируют поток на определенное время.
Эти методы представлены в следующем виде:

Вызывает | Exception | Чтение значения | Блокировка    | Чтение с задержкой
------------------------------------------------------------------------------
Insert	 | add(e)    | offer(e)        | put(e)        | offer(e, time, unit)
Remove	 | remove()  | poll()          | take()        | poll(time, unit)
Проверка | element() |	peek()         | не применимый | не применимый
------------------------------------------------------------------------------
(см.пример Less_25_BlockingQueue_Step3)

************ Интерфейс BlockingDeque ************

Интерфейс BlockingDeque, также, как и BlockingQueue, определяет блокирующую, но
двунаправленную очередь, наследующую свойства интерфейса Deque и ориентированную на
многопотоковое исполнение, не разрешающую нулевые элементы и с возможностью
ограничения емкости. Реализации интерфейса BlockingDeque блокируют операции получения
элементов, если очередь пустая, и добавления элемента в очередь, если она полная.

Методы BlockingDeque объединены в 4 группы, по-разному реагирующие на невозможность
выполнения операции в текущий момент и откладывающие их выполнение на небольшое время:
- первые вызывают Exception;
- вторые возвращают определенное значение (null или false);
- третьи блокируют поток на неопределенное время до момента выполнения операции;
- четвертые блокируют поток на определенное время.
Методы представлены в следующей таблице:

Первый Элемент (голова):
---------------------------------------------------------------------------------------
Вызывает | Exception     | Чтение значения | Блокировка    | Чтение с задержкой
---------------------------------------------------------------------------------------
Insert	 | addFirst(e)   | offerFirst(e)   | putFirst(e)   | offerFirst(e, time, unit)
Remove	 | removeFirst() | pollFirst()     | takeFirst()   | pollFirst(time, unit)
Проверка | getFirst()    | peekFirst()     | не применимый | не применимый
---------------------------------------------------------------------------------------
Последний Элемент (хвост)
---------------------------------------------------------------------------------------
Insert	 | addLast(e)    | offerLast(e)    | putLast(e)    | offerLast(e, time, unit)
Remove	 | removeLast()  | pollLast()      | takeLast()    | pollLast(time, unit)
Проверка | addLast       | peekLast()      | не применимый | не применимый
---------------------------------------------------------------------------------------

Реализация BlockingDeque может использоваться непосредственно в качестве BlockingQueue
с механизмом FIFO. Следующие представленные в таблице методы и наследованные от интерфейса
BlockingQueue, точно эквивалентны методам BlockingDeque :

BlockingQueue method | Equivalent BlockingDeque method
------------------------------------------------------------
Insert
------------------------------------------------------------
add(e)	             | addLast(e)
offer(e)             | offerLast(e)
put(e)	             | putLast(e)
offer(e, time, unit) | offerLast(e, time, unit)
------------------------------------------------------------
Remove
------------------------------------------------------------
remove()             | removeFirst()
poll()               | pollFirst()
take()               | takeFirst()
poll(time, unit)     | pollFirst(time, unit)
------------------------------------------------------------
Examine (Проверка)
------------------------------------------------------------
element()            | getFirst()
peek()               | peekFirst()
------------------------------------------------------------
Действия по размещению объекта в BlockingDeque выполняйте перед действиями проверки
доступа или удаления элемента из очереди в другом потоке.

************ Очередь ArrayBlockingQueue ************

Класс блокирующей очереди ArrayBlockingQueue реализует классический ограниченного размера
кольцевой буфер FIFO — «первым прибыл - первым убыл». Новые элементы вставляются в хвост
очереди; операции извлечения отдают элемент из головы очереди. Создаваемая емкость очереди
не может быть изменена.

Попытки вставить (put) элемент в полную очередь приведет к блокированию работы потока,
попытка извлечь (take) элемент из пустой очереди также блокирует поток.

Данный класс поддерживает дополнительную политику справедливости параметром fair в конструкторе
для упорядочивания работы ожидающих потоков производителей (вставляющих элементы) и потребителей
(извлекающих элементы). По умолчанию упорядочивание работы очереди не гарантируется. Но если очередь
создана с «fair=true», реализация класса ArrayBlockingQueue предоставляет доступ потоков в порядке
FIFO. Справедливость обычно уменьшает пропускную способность, но также снижает изменчивость и
предупреждает исчерпание ресурсов.

Класс ArrayBlockingQueue и его iterator реализуют все дополнительные методы Collection и Iterator.
Метод toArray() возвращает массив элементов очереди типа Object[].

Конструкторы класса ArrayBlockingQueue:
- ArrayBlockingQueue(int capacity) - конструктор создает очередь фиксированной емкости, c политикой
                                     доступа по умолчанию.
- ArrayBlockingQueue(int capacity, boolean fair) - конструктор с фиксированной емкостью и указанной
                                                   политикой доступа.
- ArrayBlockingQueue(int capacity, boolean fair,
                   Collection<? extends E> c) - конструктор создает очередь с фиксированной емкостью,
                                                указанной политикой доступа и включает в очередь элементы.

************ Очередь LinkedBlockingQueue ************

Класс блокирующей очереди LinkedBlockingQueue, основанный на соединенных узлах, регулирует
порядок поступления и выдачи элементов FIFO — «первым прибыл - первым убыл». Новые элементы
вставляются в хвост очереди, а операции чтения извлекают элемент из головы очереди.
У соединенных на узлах очереди обычно более высокая пропускная способность, чем у основанной
на массиве очереди, но менее предсказуемая производительность в большинстве многопоточных
приложений.

Конструкторы класса LinkedBlockingQueue
- LinkedBlockingQueue() - конструктор создает пустую очередь фиксированной емкости.
- LinkedBlockingQueue(int capacity) - конструктор создает очередь с фиксированной емкостью capacity.
- LinkedBlockingQueue(Collection<? extends E> c) - конструктор создает очередь с набором элементов.

Если используется конструктор без указания емкости очереди, то используется значение по умолчанию
Integer.MAX_VALUE.

Класс LinkedBlockingQueue и его iterator реализуют все опциональные методы Collection и Iterator.
Метод toArray() возвращает массив элементов очереди типа Object[].

************ Очередь LinkedBlockingDeque ************

Класс LinkedBlockingDeque создает двунаправленную очередь с реализацией интерфейса
BlockingDeque, наследуемого от интерфейса Deque. Данный класс может иметь ограничение
на количество элементов в очереди. Если ограничение не задано, то оно равно значению
Integer.MAX_VALUE.

Конструкторы класса:
- LinkedBlockingDeque();
- LinkedBlockingDeque(int capacity);
- LinkedBlockingDeque(Collection<? extends E> c);

Класс LinkedBlockingDeque и его iterator реализуют все опциональные методы Collection и Iterator.

Элементы в двустороннюю очередь LinkedBlockingDeque можно добавлять при помощи следующих методов:
- boolean add(E e);
- void addFirst(E e);
- void addLast(E e);

Метод add() аналогичен методу addLast(). В случае нехватки места в двусторонней очереди вызывается
исключение IllegalStateException.

Элементы можно также добавить при помощи следующих методов :
- boolean offer(E e);
- boolean offerFirst(E e);
- boolean offerLast(E e);

В отличие от добавления элементов при помощи метода add...(), при добавлении элементов методом
offer...() возвращается false, если элемент не может быть добавлен.

Для удаления элементов имеются методы:
- remove();
- removeFirst();
- removeLast();
Методы remove...() выбрасывают исключение NoSuchElementException при пустой двусторонней очереди.
- poll();
- pollFirst();
- pollLast();
Методы poll...() используются для чтения с удалением и возвращают значение null, если очередь пуста.

Несмотря на то, что работа с двусторонними очередями предполагает удаление элементов только
с концов очереди, можно удалять определенный объект очереди при помощи следующих методов:
- boolean remove(Object o)
- boolean removeFirstOccurrence(Object o)
- boolean removeLastOccurrence(Object o)

Так как концептуально двусторонняя очередь является привязанной с двух сторон, то можно
проводить поиск элементов в любом порядке. Итератор iterator() можно использовать для поиска
элементов с начала до конца, а descendingIterator() — для поиска элементов в обратном
направлении с конца до начала.

!!! Однако нельзя получить доступ к элементу по его местоположению !!!

Метод toArray() возвращает массив элементов очереди типа Object[].

Двусторонние очереди позволяют сформировать удобные структуры данных при использовании
рекурсивных процедур, как, например, работа с лабиринтами и разбор исходных данных.
Так, при разборе исходных данных, можно сохранять правильные варианты в очереди,
добавляя их с одной стороны. Если вариант при проверке оказывается неверным, то он
удаляется, возвращаясь к последнему верному элементу. В этом случае используется только
одна сторона очереди, как в стеке. При достижении «дна» необходимо вернуться в начало
для получения решения, которое начинается с последнего элемента. Другим типичным примером
является планировщик заданий в операционной системе.

Пример демонстрирует использование интерфейса BlockingDeque,
а вернее его реализацию — класса LinkedBlockingDeque с установленными границами.
Это далеко не лучший пример использования двусторонней очереди, но он позволяет
показать применение API и возникающие при достижении предела очереди события.
(см. пример Less_25_LinkedBlockingDeque_Step4)

************ Очередь SynchronousQueue ************

Класс SynchronousQueue формирует блокирующую очередь, в которой каждая операция
добавления в одном потоке должна ждать соответствующей операции удаления в другом
потоке и наоборот. В сущности, SynchronousQueue является еще одной реализацией
представленного выше интерфейса BlockingQueue. Данный тип очереди предоставляет
удобный способ обмена одиночными элементами между потоками посредством семантики
блокировки, используемой в ArrayBlockingQueue.

Синхронная очередь не имеет внутренней емкости, даже в один элемент.
(см. пример Less_25_SynchQueues_Step5)

************ Очередь LinkedTransferQueue ************

В отличие от реализации очередей интерфейса BlockingQueue, где потоки могут быть
блокированы при чтении, если очередь пустая, либо при записи, если очередь полная,
очереди интерфейса TransferQueue блокируют поток записи до тех пор, пока другой
поток не извлечет элемент. Для этого следует использовать метод transfer.

Иначе говоря, реализация BlockingQueue гарантирует, что элемент, созданный
производителем (Producer), должен находиться в очереди, в то время как реализация
TransferQueue гарантирует, что элемент Producer'а «получает» потребитель (Consumer).
(см. пример Less_25_TransferQueue_Step6)

************ Очередь DelayQueue ************

Неограниченная очередь блокирования элементов DelayQueue реализует интерфейс Delayed
и позволяет извлекать элемент с некоторой временно́й задержкой. Если задержка не истекла,
то метод poll вернет null. Очередь не разрешает запись нулевых элементов.

Метод класса getDelay(TimeUnit.NANOSECONDS) вернет значение меньше или равное нулю,
если время еще не истекло.

Метод size возвращает общее количество элементов с истекшим и неистекшим временем задержки.

Класс DelayQueue и его iterator реализуют все дополнительные методы Collection и Iterator интерфейсы.
