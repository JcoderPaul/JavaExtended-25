### Cинхронизированные коллекции

Фреймворк collections является ключевым компонентом Java. Он предоставляет большое
количество интерфейсов и реализаций, что позволяет нам создавать различные типы
коллекций и управлять ими простым способом.

Хотя использование и управление простыми несинхронизированными коллекциями в целом
предсказуемо, но это может стать сложным и подверженным ошибкам процессом при работе
в многопоточных средах.

Для обхода этой проблемы в Java создали различные оболочки обертки для синхронизации,
которые реализованы в классе Collections.

Эти оболочки позволяют легко создавать синхронизированные представления (view) нужных
коллекций с помощью нескольких статических фабричных методов:

- **Метод synchronizedCollection()** - Синхронизированная оболочка - возвращает потокобезопасную коллекцию, резервную копию которой
создает указанная коллекция (Collection).

(см. пример [Less_25_SynchronizedCollection_Step4](./Less_25_SynchronizedCollection_Step4.java))

- **Метод synchronizedList()** - 
Аналогично методу synchronizedCollection (), мы можем использовать оболочку synchronizedList()
для создания синхронизированного cписка (List). Метод возвращает потокобезопасное представление
указанного списка : List syncList = Collections.synchronizedList(new ArrayList<>());

Использование метода synchronizedList() выглядит почти идентично его аналогу более высокого уровня,
synchronizedCollection().

(см. пример [Less_25_SynchronizedCollection_Step3](./Less_25_SynchronizedCollection_Step3.java))

    !!! Если мы хотим выполнить итерацию по синхронизированной коллекции и хотим избежать
    неожиданных результатов, мы должны явно реализовать синхронизацию цикла итератора,
    заключив его в синхронизированный блок!!!

(см. пример [Less_25_SynchronizedCollection_Step3](./Less_25_SynchronizedCollection_Step3.java))

Во всех случаях, когда нам нужно выполнить итерацию по синхронизированной коллекции, мы
должны реализовать эту идиому. Это связано с тем, что итерация синхронизированной коллекции
выполняется с помощью нескольких вызовов коллекции. Поэтому они должны выполняться как единая
атомарная операция.

---

- **Метод synchronizedMap()** - Данный метод используется для простого создания синхронизированной Map коллекции.

    Пример: Map syncMap = Collections.synchronizedMap(new HashMap<>());

- **Метод synchronizedSortedMap()** - Метод который можно использовать для создания синхронизированной SortedMap коллекции.

    Пример: Map syncSortedMap = Collections.synchronizedSortedMap(new TreeMap<>());

- **Метод synchronizedSet()** - Данный метод позволяет создавать синхронизированные наборы Set.
  
    Пример: Set syncSet = Collections.synchronizedSet(new HashSet<>());

- **Метод synchronizedSortedSet()** - Метод возвращает потокобезопасную версию отсортированного Set-а SortedSet.
  
    Пример: SortedSet syncSortedSet = Collections.synchronizedSortedSet(new TreeSet<>());

---
Синхронизированные коллекции обеспечивают потокобезопасность за счет блокировки монитора, и все
коллекции блокируются. Внутренняя блокировка реализуется с помощью синхронизированных блоков в
рамках методов обернутой коллекции.

Как и следовало ожидать, синхронизированные коллекции обеспечивают согласованность/целостность
данных в многопоточных средах. Однако они могут привести к снижению производительности, так как
ТОЛЬКО ОДИН поток может одновременно получить доступ к коллекции (он же синхронизированный доступ).

Созданные обертки выполняют роль декораторов, в которых методы работы с элементами коллекций
такие как метод get и метод put синхронизированы посредством блокировки.

    !!! Важно запомнить, что после создания потокобезопасных декораторов обращение к базовой
    структуре данных должно происходить, только через эти синхронизированные декораторы !!!

Еще раз java.util.Collections обеспечивает следующие синхронизирующие методы:
- public static Collection synchronizedCollection(Collection c);
- public static List synchronizedList(List list);
- public static Map synchronizedMap(Map m);
- public static Set synchronizedSet(Set s);
- public static SortedMap synchronizedSortedMap(SortedMap m);
- public static SortedSet synchronizedSortedSet(SortedSet s);

И снова, повторим, обертки управляют лишь методами набора данных get и put.
Для обхода синхронизированной коллекции, код обхода коллекции должен быть
синхронизирован на самой обертке.

---

    List synchList = Collections.synchronizedList(new ArrayList());
    
      synchronized (synchList) {
        Iterator iter = synchList.iterator();
        while (iter.hasNext()){
               . . .               // Do something
        }
     }
