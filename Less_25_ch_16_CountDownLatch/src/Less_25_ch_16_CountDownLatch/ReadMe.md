### Класс CountDownLatch

Иногда требуется, чтобы поток исполнения находился в режиме ожидания до тех пор,
пока не наступит одно или больше событий. Для этих целей в многопоточном программировании
создан класс CountDownLatch, реализующий блокировку потоков с обратным отсчетом.

Объект этого класса изначально создается с количеством событий, которые должны произойти
до того момента, как будет снята блокировка потоков. Всякий раз, когда происходит событие,
значение счетчика уменьшается.

Как только значение счетчика достигнет нуля, блокировка потоков будет снята.

В классе CountDownLatch имеется приведенный ниже конструктор, где параметр 'число'
определяет количество событий, которые должны произойти до того, как будет снята
блокировка.

    CountDownLatch(int число)

Для ожидания по счетчику CountDownLatch в потоке исполнения вызывается метод await(),
общие формы которого приведены ниже:
- void await() throws InterruptedException - ожидание длится до тех пор, пока отсчет,
  связанный с вызывающим объектом типа CountDownLatch, не достигнет нуля.

(см. пример [Less_25_CountDownLatch_Step1](./Less_25_CountDownLatch_Step1.java))

- boolean await(long 'ожидание', TimeUnit 'единица_времени') throws InterruptedException - ожидание
длится только в течение определенного периода времени, определяемого параметром 'ожидание'. Время
ожидания указывается в единицах, обозначаемых параметром 'единица_времени', который принимает объект
перечисления TimeUnit.

(см. пример [Less_25_CountDownLatch_Step2](./Less_25_CountDownLatch_Step2.java))

Метод await() изначально возвращает логическое значение false. Если достигнут предел времени ожидания, или
если обратный отсчет достигает нуля, тогда возвращается true.

Чтобы известить о событии которое повлияло на изменение счетчика CountDownLatch, следует вызвать метод
countDown(). Всякий раз, когда вызывается метод countDown() на объекте счетчике, отсчет, связанный с
вызывающим объектом, уменьшается на единицу.

Класс CountDownLatch является эффективным и простым в употреблении средством синхронизации, которое
окажется полезным в тех случаях, когда поток исполнения должен находиться в состоянии ожидания до тех
пор, пока не произойдет одно или несколько событий
