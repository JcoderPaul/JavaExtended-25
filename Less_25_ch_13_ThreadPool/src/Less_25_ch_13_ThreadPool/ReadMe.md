### ThreadPool или Пулы потоков

Создавать потоки для выполнения большого количества задач очень трудоемко:
создание потока и освобождение ресурсов — дорогостоящие операции. Для решения
проблемы ввели пулы потоков и очереди задач, из которых берутся задачи для пулов.

Пул потоков — своего рода контейнер, в котором содержатся потоки, которые могут
выполнять задачи, и после выполнения очередной самостоятельно переходить к следующей.

Вторая причина создания пулов потоков — возможность разделить объект, выполняющий код,
и непосредственно код задачи, которую необходимо выполнить. Использование пула потоков
обеспечивает лучший контроль создания потоков и экономит ресурсы создания потоков.
Также использование пула потоков упрощает разработку многопоточных программ, упрощая
создание и манипулирование потоками. За созданием и управлением пулом потоков отвечают
несколько классов и интерфейсов, которые называются "Executor Framework in Java".

---
### Executor Framework

Рассмотрим основные интерфейсы и классы, входящие в этот фреймворк.
Его основные интерфейсы:

    - Executor - интерфейс, содержащий метод execute() для запуска задачи, заданной запускаемым
                 объектом Runnable;
    
    - ExecutorService - интерфейс потомок интерфейса Executor, который добавляет функциональность
                        для управления жизненным циклом потоков. Он включает в себя метод submit(),
                        который аналогичен методу execute(), но более универсален. Перегруженные
                        версии метода submit() могут принимать как выполняемый (Runnable), так и
                        вызываемый (Callable) объект. Вызываемые объекты аналогичны выполняемым,
                        за тем исключением, что задача, определенная вызываемым объектом, также может
                        возвращать значение. Поэтому, если мы передаем объект Callable методу submit(),
                        он возвращает объект Future. Этот объект можно использовать для получения
                        возвращаемого значения Callable и управления статусом как Callable, так и
                        Runnable задач.
    
    - ScheduledExecutorService - интерфейс потомок от ExecutorService. Он добавляет функциональность,
                                 которая позволяет планировать выполнение задач в коде.
    
    - Executors - класс, который по умолчанию включает в себя методы для создания различных типов
                  служб-исполнителей. С помощью этого класса и интерфейсов можно создавать пулы потоков.

Объекты, которые реализуют интерфейс Executor, могут выполнять runnable-задачу. Интерфейс Executor имеет
один метод void execute(Runnable command). После вызова этого метода и передачи задачи на выполнение,
задача в будущем будет выполнена асинхронно. Также этот интерфейс разделяет, кто будет выполнять задачу
и что будет выполняться! В отличие от класса Thread.

Интерфейс ExecutorService наследуется от интерфейса Executor и предоставляет возможности для выполнения
заданий Callable, для прерывания выполняемой задачи и завершения работы пула потоков. Для выполнения задач,
которые возвращают результат, существует метод submit(), возвращающий объект, который реализует интерфейс
Future<T>. С помощью этого объекта можно узнать, есть ли результат, вызовом метода isDone(). С помощью метода
get() можно получить результат выполнения задачи, если он есть. Также можно отменить задание на выполнение
при помощи метода cancel().

Класс Executors — утилитный клас, как например, класс Collections. Класс Executors создает классы, которые
реализуют интерфейсы Executor и ExecutorService. В классе Executors есть четыре основных метода, которые
используются для создания пулов потоков:

    - Executors.newFixedThreadPool(Thread N) — пул потоков, который содержит фиксированное количество потоков.

Таким образом, когда мы, например, отправим 'X' задач, будет создано 'N' новых потоков и будут выполнено 'N'
задач. Если (Х > N), то остальные (X - N) задачи находятся в очереди ожидания. Как только какая-либо задача
выполнится потоком, и он освободится этим же потоком будет выбрана и выполнена следующая задача.
(см. пример Less_25_ThreadPool_Step1)

    - Executors.newSingleThreadExecutor() — пул потоков, в котором есть только один поток.

В данном случае будет создан только один новый поток и одновременно будет выполняться только одна задача.
Остальные 'X' задач находятся в очереди ожидания. Как только задача выполнится потоком, этот поток тут же
выберет и выполнит следующую и т.д.
(см. пример Less_25_ThreadPool_Step2)

    - Executors.newCachedThreadPool() - возвращает пул потоков, если в пуле не хватает потоков, в нем будет создан
                                        новый поток.

Когда мы создаем пул потоков с помощью этого метода, максимальный размер пула потоков устанавливается на
максимальное целочисленное значение в Java, необходимое для текущей работы. Этот метод создает новые потоки
по запросу и разрушает потоки, которые простаивают больше минуты, если запрос отсутствует.

Таким образом, этот метод — хороший выбор, если нам хочется добиться большей производительности очереди,
чем это возможно с методом newFixedThreadPool(). Но если мы хотим ограничить количество параллельно
выполняемых задач во имя управления ресурсами, лучше использовать newFixedThreadPool().

    - Executors.newScheduledThreadPool(Tread N) — этот пул потоков позволяет запускать задания с
                                                  определенной периодичностью или один раз по истечении
                                                  промежутка времени, количество заранее созданных потоков
                                                  можно задавать.

Метод newScheduledThreadPool() создает пул потоков, который может планировать выполнение задач после
заданной задержки или через регулярные промежутки времени. Этот метод возвращает ScheduledExecutorService.
Существует три метода для планирования задач в таком пуле потоков:
    - schedule() - метод принимает три аргумента: задачу, задержку и промежуток времени задержки,
                   используется для планирования задачи после фиксированной задержки;
    - scheduleAtFixedRate() - метод используется для планирования задачи после фиксированной задержки и
                              последующего периодического выполнения этой задачи;
    - scheduleWithFixedDelay() - метод используется для планирования задачи после начальной задержки,
                                 а затем выполнения задач с фиксированной задержкой после завершения
                                 предыдущей задачи..
  
---
### !!! Важные замечания как использовать фреймворк Executor !!!

- Никогда не ставить в очередь задачи, которые в это самое время ожидают результатов от других задач.
  Это может привести к тупику.

- Пул потоков, после окончания работы, должен быть явно завершен путем вызова метода shutdown().
  Если этого не сделать, программа будет продолжать работать без конца. Если мы отправим исполнителю
  другую задачу после завершения работы, она выдаст исключение RejectedExecutionException.

- Нужно с осторожностью, применять потоки для длительных операций. Это может привести к бесконечному
  ожиданию потока и в конечном итоге — к утечке ресурсов.

- Для эффективной настройки пула потоков необходимо понимать особенности задач. Если задачи очень разные,
  имеет смысл использовать разные пулы потоков для разных типов задач, чтобы правильно их настроить.
