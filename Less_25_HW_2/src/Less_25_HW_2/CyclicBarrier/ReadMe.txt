******* Класс CyclicBarrier *******

В программировании нередко возникают такие ситуации, когда два или более потоков
должны находиться в режиме ожидания в предопределенной точке исполнения до тех пор,
пока все эти потоки не достигнут данной точки.

Барьерная синхронизация — метод синхронизации в распределённых вычислениях, при
котором выполнение параллельного алгоритма или его части можно разделить на несколько
этапов, разделённых барьерами. В частности, с помощью барьера можно организовать
точку сбора частичных результатов вычислений, в которой подводится итог этапа
вычислений.

Использование барьеров как примитивов синхронизации особенно полезно при циклической
организации этапов расчетов.

Барьер для группы потоков (или процессов) в исходном коде означает, что каждый поток
(процесс) должен остановиться в этой точке и подождать достижения барьера всеми потоками
(процессами) группы. Когда все потоки (процессы) достигли барьера, их выполнение
продолжается.

*** CyclicBarrier ***

CyclicBarrier реализует шаблон синхронизации 'Барьер'. Циклический барьер является точкой
синхронизации, в которой указанное количество параллельных потоков встречается и блокируется.
Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если
барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и
ожидающие потоки «освобождаются».

В конструктор барьера (CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction))
обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие,
которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

Барьер похож на CountDownLatch, но главное различие между ними в том, что мы не можем заново
использовать «замок» - CountDownLatch после того, как его счётчик достигнет нуля, а барьер мы
можем использовать снова, даже после того, как он сломается (достигнет заданного значения).

CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того,
как они выполнились.

*** Class CyclicBarrier ***

public class CyclicBarrier extends Object

Средство синхронизации, позволяющее всем потокам ожидать друг друга, пока они не достигнут общей
точки - барьера. CyclicBarriers полезны в программах, включающих группу потоков фиксированного размера,
которые должны время от времени ожидать друг друга. Барьер называется циклическим, потому что его можно
использовать повторно после освобождения ожидающих потоков.

CyclicBarrier поддерживает необязательную команду Runnable, которая запускается один раз для каждой
точки барьера после прибытия последнего потока в группе, но до освобождения каких-либо потоков.
Это барьерное действие полезно для обновления общего состояния до того, как какая-либо из сторон
продолжит работу.

CyclicBarrier использует модель отказа «все или ничего» для неудачных попыток синхронизации: если
поток покидает точку барьера преждевременно из-за прерывания, сбоя или тайм-аута, все остальные
потоки, ожидающие в этой точке барьера, также аварийно завершатся через BrokenBarrierException
(или InterruptedException, если они тоже были прерваны примерно в одно и то же время).

Эффекты согласованности памяти: действия в потоке до вызова await() происходят до действий,
которые являются частью барьерного действия, которые, в свою очередь, происходят до действий,
следующих за успешным возвратом из соответствующего await() в других потоках.

*** Методы ***
- int await() - Ожидает, пока все стороны не вызовут await на этом барьере.

Ожидает, пока все стороны не вызовут await на этом барьере.
Если текущий поток прибыл не последним, то он отключается в
целях планирования потоков и остается бездействующим до тех пор,
пока не произойдет одно из следующих событий:
- приходит последний поток;
- какой-то другой поток прерывает текущий поток;
- какой-то другой поток прерывает один из других ожидающих потоков;
- таймаут некоторых других потоков в ожидании барьера;
- какой-то другой поток вызывает reset() для данного текущего барьера.

Если текущий поток:
- имеет установленный статус прерывания при входе в этот метод;
- или же прерывается во время ожидания;
то, генерируется InterruptedException, и состояние прерванного
текущего потока сбрасывается.

Если барьер reset() во время ожидания любого потока, или если
барьер нарушается при вызове await, или во время ожидания любого
потока, выбрасывается исключение BrokenBarrierException.

Если какой-либо поток прерывается во время ожидания, то все остальные
ожидающие потоки будут генерировать исключение BrokenBarrierException,
и барьер будет переведен в сломанное состояние - 'broken state'.

Если текущий поток является последним прибывшим потоком, а в конструкторе
было указано ненулевое барьерное действие, то текущий поток выполняет
действие, прежде чем позволить другим потокам продолжить работу. Если во
время действия барьера возникает исключение, то это исключение будет
распространено в текущем потоке, и барьер будет переведен в сломанное
состояние - 'broken state'.

Возвращает: индекс прибытия текущего потока, где индекс getParties() - 1
            указывает на прибытие первым, а ноль указывает на прибытие
            последним
Исключения:
InterruptedException - если текущий поток был прерван во время ожидания;
BrokenBarrierException — если другой поток был прерван или истекло время
ожидания текущего потока, или барьер был сброшен, или барьер был сломан при
вызове await, или действие барьера (если оно присутствует) не удалось из-за
исключения.

- int await(long timeout, TimeUnit unit) - Ожидает, пока все стороны не вызовут
                                         await на этом барьере, или пока не истечет
                                         указанное время ожидания.

- int getNumberWaiting() - Возвращает количество сторон, ожидающих в данный момент у барьера.

- int getParties() - Возвращает количество сторон, необходимое для преодоления этого барьера.

- boolean isBroken() - Запрашивает, не сломан ли этот барьер.

- void reset() - Сбрасывает барьер в исходное состояние.

см. документацию: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html